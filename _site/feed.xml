<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2016-12-14T23:40:49+08:00</updated><id>http://localhost:4000//</id><title type="html">heavyhuang的个人笔记</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</subtitle><entry><title type="html">深入了解Java虚拟机学习笔记</title><link href="http://localhost:4000/jekyll/update/2016/12/14/jvm.html" rel="alternate" type="text/html" title="深入了解Java虚拟机学习笔记" /><published>2016-12-14T22:32:38+08:00</published><updated>2016-12-14T22:32:38+08:00</updated><id>http://localhost:4000/jekyll/update/2016/12/14/jvm</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2016/12/14/jvm.html">&lt;h2 id=&quot;一内存区域&quot;&gt;一.内存区域&lt;/h2&gt;
&lt;h3 id=&quot;1程序计数器&quot;&gt;1.程序计数器&lt;/h3&gt;
&lt;p&gt;线程私有，字节码的行号指示器，为了每个线程在CPU处理完后能恢复到正确位置。&lt;/p&gt;
&lt;h3 id=&quot;2java虚拟机栈&quot;&gt;2.Java虚拟机栈&lt;/h3&gt;
&lt;p&gt;线程私有，执行Java字节码，存有&lt;strong&gt;局部变量表&lt;/strong&gt;（编译器可知基本数据类型，对象引用）、操作数栈、动态链接、方法出口等信息。&lt;/p&gt;
&lt;h3 id=&quot;3本地方法栈&quot;&gt;3.本地方法栈&lt;/h3&gt;
&lt;p&gt;执行Native方法。&lt;/p&gt;
&lt;h3 id=&quot;4java堆&quot;&gt;4.Java堆&lt;/h3&gt;
&lt;p&gt;线程共享，存放对象实例和数组（不绝对），GC中新生代老年代，处于物理上不连续但逻辑连续的内存空间中。&lt;/p&gt;
&lt;h3 id=&quot;5方法区&quot;&gt;5.方法区&lt;/h3&gt;
&lt;p&gt;线程共享，存放常量、静态变量、虚拟机加载的类信息，GC中永久代。&lt;/p&gt;
&lt;h3 id=&quot;6常量池&quot;&gt;6.常量池&lt;/h3&gt;
&lt;p&gt;方法区一部分，存放编译期生成的各种字面量和符号引用，具备动态加载性。&lt;/p&gt;
&lt;h3 id=&quot;7直接内存&quot;&gt;7.直接内存&lt;/h3&gt;
&lt;p&gt;NIO中buffer分配内存，避免Java堆和Native堆中来回复制数据。&lt;/p&gt;

&lt;h2 id=&quot;二内存布局&quot;&gt;二.内存布局&lt;/h2&gt;
&lt;h3 id=&quot;1对象头&quot;&gt;1.对象头&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;第一部分储存对象运行时数据，包括哈希码、GC分代年龄、线程持有锁、偏向锁ID、偏向时间戳等，又称为“Mark Word”。&lt;/li&gt;
  &lt;li&gt;第二部分是类型指针，Jvm通过该指针确定这个对象是那个类的实例。若指向数组，则对象头还有一块用于记录数组长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2实例数据&quot;&gt;2.实例数据&lt;/h3&gt;
&lt;p&gt;对象真正储存的有效信息，父类定义的变量会出现在子类之前。&lt;/p&gt;
&lt;h3 id=&quot;3对齐填充&quot;&gt;3.对齐填充&lt;/h3&gt;
&lt;p&gt;Jvm要求对象起始地址必须是8字节的整数倍。当对象实例数据没有对齐时，通过对齐填充补全。&lt;/p&gt;

&lt;h3 id=&quot;4对象访问定位&quot;&gt;4.对象访问定位&lt;/h3&gt;
&lt;p&gt;使用句柄：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Java堆划分出一块内存作为句柄池，reference(指向对象的引用)中储存对象句柄地址，句柄包含对象实例数据和类型数据各自具体地址信息。&lt;/li&gt;
  &lt;li&gt;对象被移动（垃圾回收时会移动对象）时只需改变句柄中实例指针。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;直接指针：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;reference中直接储存对象地址。&lt;/li&gt;
  &lt;li&gt;速度快，节省一次指针定位开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三垃圾收集算法&quot;&gt;三.垃圾收集算法&lt;/h2&gt;

&lt;h3 id=&quot;引用计数法&quot;&gt;引用计数法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;给对象添加一个引用计数器，被引用时加一；引用失效时减一。&lt;/li&gt;
  &lt;li&gt;很难解决循环引用的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;可达分析法&quot;&gt;可达分析法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;GC Roots：虚拟机栈中引用的对象，静态引用的对象，常量引用的对象，JNI引用的对象。&lt;/li&gt;
  &lt;li&gt;强引用：Object obj = new Object();只要强引用在，垃圾收集器永远不会回收被引用的对象。&lt;/li&gt;
  &lt;li&gt;软引用：有用但非必需的对象。在内存溢出之前才会回收。SoftReference类实现软引用。&lt;/li&gt;
  &lt;li&gt;弱引用：强度低于软引用。被引用对象只能生存到下次垃圾收集前。&lt;/li&gt;
  &lt;li&gt;虚引用：最弱的引用。唯一作用对象被回收前收到一个系统通知。PhantonReference类。&lt;/li&gt;
  &lt;li&gt;若对象被判定执行finalize()方法，则会放到F-Queue队列中，并在稍后由一个虚拟机自动建立、低优先级的Finalizer线程去执行。&lt;/li&gt;
  &lt;li&gt;F-Queue中对象可在GC对F-Queue进行二次标记前拯救自己。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;标记-清除法&quot;&gt;标记-清除法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;用于回收老年代。&lt;/li&gt;
  &lt;li&gt;缺点：标记和清除两个效率低。会产生大量不连续空间碎片，可能导致分配较大对象时触发另一次垃圾回收。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;复制算法&quot;&gt;复制算法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;用于回收新生代。&lt;/li&gt;
  &lt;li&gt;将内存划分为较大的Eden代和两块较小的Survivor空间。&lt;/li&gt;
  &lt;li&gt;回收时将Eden和Survivor中还存活的对象一次性复制到另一块Survivor中，然后清理Eden和刚才的Suivivor空间。&lt;/li&gt;
  &lt;li&gt;若Survivor空间不够，则放入老年代。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;标记-整理法&quot;&gt;标记-整理法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;用于回收老年代。&lt;/li&gt;
  &lt;li&gt;类似标记-清除法，清除完后将存活对象在内存中向一端移动，然后直接清理边界以外的内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;安全点safepoint&quot;&gt;安全点（Safepoint）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;程序到安全点时才停顿下来开始GC。&lt;/li&gt;
  &lt;li&gt;安全点选定不能太少让GC等待太长，也不能过于频繁增大运行时的负荷，以“是否让程序长时间执行的特征”来选定。&lt;/li&gt;
  &lt;li&gt;方法调用、循环跳转、异常跳转等功能指令会产生安全点。&lt;/li&gt;
  &lt;li&gt;抢先式中断（不推荐）&lt;/li&gt;
  &lt;li&gt;主动式中断：GC简单的设置一个标志，各线程轮询该标志，若发现标志为真则挂起。轮询标志和安全点位置重合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四垃圾收集器&quot;&gt;四.垃圾收集器&lt;/h2&gt;

&lt;h3 id=&quot;serial收集器&quot;&gt;Serial收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;新生代复制算法（暂停所有用户线程）&lt;/li&gt;
  &lt;li&gt;老年代标记-整理法（暂停所有用户线程）&lt;/li&gt;
  &lt;li&gt;单线程，简单而高效&lt;/li&gt;
  &lt;li&gt;能与CMS配合工作&lt;/li&gt;
  &lt;li&gt;指针碰撞，内存规整&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;parnew收集器&quot;&gt;ParNew收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Serial多线程版本&lt;/li&gt;
  &lt;li&gt;新生代复制算法（暂停所有线程，多线程）&lt;/li&gt;
  &lt;li&gt;老年代标记-整理法（暂停所有用户线程）&lt;/li&gt;
  &lt;li&gt;能与CMS配合工作&lt;/li&gt;
  &lt;li&gt;指针碰撞，内存规整&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;parallel-scavenge收集器&quot;&gt;Parallel Scavenge收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;新生代收集器，使用复制算法&lt;/li&gt;
  &lt;li&gt;吞吐量优先&lt;/li&gt;
  &lt;li&gt;打开-XX:+UseAdaptiveSizePolicy后不需手动指定新生代参数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;serial-old收集器&quot;&gt;Serial Old收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;新生代复制算法（暂停所有用户线程）&lt;/li&gt;
  &lt;li&gt;老年代标记-整理法（暂停所有用户线程）&lt;/li&gt;
  &lt;li&gt;Serial老年代版本&lt;/li&gt;
  &lt;li&gt;可与Parallel Scavenge搭配使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;parallel-old收集器&quot;&gt;Parallel Old收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Parallel Scavenge老年代版本&lt;/li&gt;
  &lt;li&gt;使用标记-整理法（多线程）&lt;/li&gt;
  &lt;li&gt;吞吐量优先（Parallel Scavenge + Parallel Old）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cms收集器&quot;&gt;CMS收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;初始标记（Stop The World）：仅标记GC Roots直接关联对象。&lt;/li&gt;
  &lt;li&gt;并发标记：GC Roots Tracing&lt;/li&gt;
  &lt;li&gt;重新标记（Stop The World）&lt;/li&gt;
  &lt;li&gt;并发清除&lt;/li&gt;
  &lt;li&gt;低停顿，对CPU资源敏感&lt;/li&gt;
  &lt;li&gt;默认回收线程数(CPU数量+3)/4&lt;/li&gt;
  &lt;li&gt;无法处理标记过程后新出现的浮动垃圾，只能留到下一次CMS。&lt;/li&gt;
  &lt;li&gt;会产生大量空间碎片。&lt;/li&gt;
  &lt;li&gt;-XX:+UseCMSCompactAtFullCollection参数用于Full GC时整理内存碎片。&lt;/li&gt;
  &lt;li&gt;空闲列表，内存相互交错&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;g1收集器&quot;&gt;G1收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;并行与并发：使用多个CPU和CPU核缩短Stop The World时间。&lt;/li&gt;
  &lt;li&gt;将Java堆划分为多个大小相等的独立区域（Region），分代概念得以保留。&lt;/li&gt;
  &lt;li&gt;基于标记-整理法。&lt;/li&gt;
  &lt;li&gt;低停顿，可建立停顿时间模型，指定M毫秒停顿时间内垃圾回收不超过N毫秒。&lt;/li&gt;
  &lt;li&gt;建立每个区域内垃圾回收优先列表，在允许GC时间内，回收价值最大的。&lt;/li&gt;
  &lt;li&gt;使用Remembered Set避免全堆扫描。&lt;/li&gt;
  &lt;li&gt;每个区域有对应Remembered Set，JVM若发现对Reference类型数据操作时，产生Write Barrier中断写操作，检查Reference是否存在某些区域中。若存在，则通过CardTable记录到对应Remembered Set中。&lt;/li&gt;
  &lt;li&gt;初始标记（Stop The World）：GC Roots直接关联的对象。&lt;/li&gt;
  &lt;li&gt;并发标记：耗时较长，标记时产生的变化放入线程Remembered Set Logs中。&lt;/li&gt;
  &lt;li&gt;最终标记（Stop The World，可并行）：Remembered Set Logs合并到Remembered Set中。&lt;/li&gt;
  &lt;li&gt;筛选回收：区域价值成本排序，根据排序回收。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;五回收策略&quot;&gt;五.回收策略&lt;/h2&gt;
&lt;h3 id=&quot;对象优先在eden分配&quot;&gt;对象优先在Eden分配&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Mirror GC：发生在新生代，非常频繁，回收速度快。&lt;/li&gt;
  &lt;li&gt;Major GC / Full GC：发生在老年代，一般比Minor GC慢十倍以上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;大对象直接进入老年代&quot;&gt;大对象直接进入老年代&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;大对象指需要连续内存空间的对象，如长字符串、大数组。&lt;/li&gt;
  &lt;li&gt;-XX：PretenureSizeThreshold参数：设置大于该参数的直接分配在老年代。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;长期存活的对象将进入老年代&quot;&gt;长期存活的对象将进入老年代&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;-XX:MaxTenuringThreshold参数：晋升老年代阈值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;动态对象年龄判定&quot;&gt;动态对象年龄判定&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;相同年龄所有对象大小总和大于Survivor一半，大于等于该年龄的直接进入老年代。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;空间分配担保&quot;&gt;空间分配担保&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Minor GC前，JVM会检查老年代最大可用连续空间是否大于新生代对象总空间，若大于，则说明Minor GC安全。&lt;/li&gt;
  &lt;li&gt;HandlePromotionFailure参数:允许冒险&lt;/li&gt;
  &lt;li&gt;若小于，且设置不允许冒险，则进行Full GC.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;六jvm常用工具&quot;&gt;六.JVM常用工具&lt;/h2&gt;

&lt;h3 id=&quot;jdk命令行工具&quot;&gt;JDK命令行工具&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jps&lt;/code&gt;:虚拟机进程状况&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jstat&lt;/code&gt;:统计虚拟机信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jinfo&lt;/code&gt;: Java配置信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jmap&lt;/code&gt;: Java内存映像，获取dump文件（堆转储快照）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jhat&lt;/code&gt;: dump分析工具&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jstack&lt;/code&gt;: Java堆栈跟踪工具&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HSDIS&lt;/code&gt;： JIT生成代码反汇编&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jdk可视化工具&quot;&gt;JDK可视化工具&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JConsole&lt;/code&gt;： Java监视与管理控制台&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VisualVM&lt;/code&gt;: 多合一故障处理工具&lt;/li&gt;
&lt;/ul&gt;</content><summary type="html">一.内存区域
1.程序计数器
线程私有，字节码的行号指示器，为了每个线程在CPU处理完后能恢复到正确位置。
2.Java虚拟机栈
线程私有，执行Java字节码，存有局部变量表（编译器可知基本数据类型，对象引用）、操作数栈、动态链接、方法出口等信息。
3.本地方法栈
执行Native方法。
4.Java堆
线程共享，存放对象实例和数组（不绝对），GC中新生代老年代，处于物理上不连续但逻辑连续的内存空间中。
5.方法区
线程共享，存放常量、静态变量、虚拟机加载的类信息，GC中永久代。
6.常量池
方法区一部分，存放编译期生成的各种字面量和符号引用，具备动态加载性。
7.直接内存
NIO中buffer分配内存，避免Java堆和Native堆中来回复制数据。</summary></entry><entry><title type="html">天河二号使用说明</title><link href="http://localhost:4000/code/2016/12/14/tianhe.html" rel="alternate" type="text/html" title="天河二号使用说明" /><published>2016-12-14T22:32:38+08:00</published><updated>2016-12-14T22:32:38+08:00</updated><id>http://localhost:4000/code/2016/12/14/tianhe</id><content type="html" xml:base="http://localhost:4000/code/2016/12/14/tianhe.html">&lt;h3 id=&quot;windows端登录&quot;&gt;Windows端登录&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;使用IE登录&lt;a href=&quot;https://vpn2.nscc-gz.cn:6443&quot;&gt;超算接入平台&lt;/a&gt;，按提示安装&lt;code class=&quot;highlighter-rouge&quot;&gt;SSLVPN&lt;/code&gt;后输入用户名密码。&lt;/li&gt;
  &lt;li&gt;此时，SSLVPN插件会自动运行。如插件提示连接不上，则需重启电脑。&lt;/li&gt;
  &lt;li&gt;安装&lt;code class=&quot;highlighter-rouge&quot;&gt;XShell&lt;/code&gt;，新建会话，属性按如下配置
    &lt;ul&gt;
      &lt;li&gt;主机填写&lt;code class=&quot;highlighter-rouge&quot;&gt;172.16.22.11&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;用户身份验证选&lt;code class=&quot;highlighter-rouge&quot;&gt;Pubilc Key&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;用户密钥选择&lt;code class=&quot;highlighter-rouge&quot;&gt;nsfc2015_304.id&lt;/code&gt;文件&lt;/li&gt;
      &lt;li&gt;用户名填&lt;code class=&quot;highlighter-rouge&quot;&gt;nsfc2015_304&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;密码为空&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;安装&lt;code class=&quot;highlighter-rouge&quot;&gt;FileZilla&lt;/code&gt;，协议选择SFTP，端口&lt;code class=&quot;highlighter-rouge&quot;&gt;23&lt;/code&gt;，其它与&lt;code class=&quot;highlighter-rouge&quot;&gt;XShell&lt;/code&gt;配置类似&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;linux端登录&quot;&gt;Linux端登录&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;安装&lt;code class=&quot;highlighter-rouge&quot;&gt;vpnc&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/vpnc/default.conf&lt;/code&gt;中加入
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IPSec gateway vpn1.nscc-gz.cn
IPSec ID nsfc2015_304
IPSec secret “共享密钥”
Xauth username nsfc2015_304
Xauth password “密码”
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;创建脚本&lt;code class=&quot;highlighter-rouge&quot;&gt;tianhe.sh&lt;/code&gt;,内容为
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
ssh -p 23 -i /path/nsfc2015_304.id nsfc2015_304@172.16.22.11
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;终端中输入
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vpnc
./tianhe.sh
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;即可登录&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;超算中环境配置&quot;&gt;超算中环境配置&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;天河使用&lt;code class=&quot;highlighter-rouge&quot;&gt;module&lt;/code&gt;来管理环境变量，但由于配置项过多，所以可以写成脚本方便配置，目前默认配置为&lt;code class=&quot;highlighter-rouge&quot;&gt;~/module_add.sh&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;MXNet的module配置
    &lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;#!/bin/bash
module purge
module unload gcc/4.9.2
module load gcc/5.2.0 glib/2.44.1 atlas/3.10.2 Python/2.7.9 opencv/2.4.11 gmp/4.3.2 mpc/0.8.1 MPFR/2.4.2 ffmpeg/0.11.1 atlas/3.10.2 atk/2.16.0 pango/1.37.0 pixman/0.32.6 libgphoto2/2.5.8 intel-compilers/15.0.1 cairo/1.14.2 intel-compilers/mkl-15 freetype/2.6 ffmpeg/0.11.1
module list
export PKG_CONFIG_PATH=/HOME/nsfc2015_304/share/pkgconfig
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;Caffe的module配置
    &lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;#!/bin/bash
module purge
module load caffe/v20160510-cpu3 java/jdk1.8.0_11 glibc/2.14 atlas/3.10.2 Python/2.7.9 gmp/4.3.2 mpc/0.8.1 MPFR/2.4.2 ffmpeg/0.11.1 MPI/Gnu/MPICH/3.1-4.9.2
module unload Python/2.7.9-fPIC 
module list
export PKG_CONFIG_PATH=/HOME/nsfc2015_304/share/pkgconfig
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pkgconfig&lt;/code&gt;中放有
    &lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;$ cat pkgconfig/opencv.pc 
#Package Information for pkg-config
prefix=/NSFCGZ/app/opencv/2.4.11
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir_old=${prefix}/include/opencv
includedir_new=${prefix}/include
Name: OpenCV
Description: Open Source Computer Vision Library
Version: 2.4.11
Libs: -L${exec_prefix}/lib  -lopencv_stitching -lopencv_objdetect -lopencv_superres -lopencv_videostab -lopencv_calib3d -lopencv_features2d -lopencv_highgui -lopencv_video -lopencv_photo -lopencv_ml -lopencv_imgproc -lopencv_flann -lopencv_core
Libs.private: -L/lib64 -lwebp -lpng -lz -ltiff -ljasper -ljpeg -lImath -lIlmImf -lIex -lHalf -lIlmThread -lgtk-3 -lgdk-3 -lpangocairo-1.0 -lpango-1.0 -latk-1.0 -lcairo-gobject -lcairo -lgdk_pixbuf-2.0 -lgio-2.0 -lgthread-2.0 -lgstvideo-1.0 -lgstapp-1.0 -lgstbase-1.0 -lgstriff-1.0 -lgstpbutils-1.0 -lgstreamer-1.0 -lgobject-2.0 -lglib-2.0 -ldc1394 -lv4l1 -lv4l2 -lavcodec -lavformat -lavutil -lswscale -lavresample -lgphoto2 -lgphoto2_port -lexif -lbz2 -ldl -lm -lpthread -lrt
Cflags: -I${includedir_old} -I${includedir_new}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;文件目录说明&quot;&gt;文件目录说明&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/tools&lt;/code&gt;下放置自己的编译好工具&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/work&lt;/code&gt;下放置开发的项目&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/data&lt;/code&gt;下放置数据集&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/parafile&lt;/code&gt;下为天河自动生成的项目性能报告&lt;/li&gt;
&lt;/ul&gt;</content><summary type="html">Windows端登录</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2016/12/14/test.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2016-12-14T22:32:38+08:00</published><updated>2016-12-14T22:32:38+08:00</updated><id>http://localhost:4000/jekyll/update/2016/12/14/test</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2016/12/14/test.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">ROS-SLAM配置教程</title><link href="http://localhost:4000/code/2016/12/14/ros-slam-tutorials.html" rel="alternate" type="text/html" title="ROS-SLAM配置教程" /><published>2016-12-14T22:32:38+08:00</published><updated>2016-12-14T22:32:38+08:00</updated><id>http://localhost:4000/code/2016/12/14/ros-slam-tutorials</id><content type="html" xml:base="http://localhost:4000/code/2016/12/14/ros-slam-tutorials.html">&lt;h3 id=&quot;一arch上安装ros&quot;&gt;一．arch上安装&lt;a href=&quot;http://wiki.ros.org/indigo/Installation/Arch&quot;&gt;ROS&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;yaourt --noconfirm ros-indigo
yaourt -S python2-rosdep
yaourt --nocomfirm rosrun
yaourt --noconfirm rosmake
yaourt --noconfirm vtk
yaourt --noconfirm glx
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;安装catkin&quot;&gt;安装&lt;a href=&quot;http://wiki.ros.org/catkin/Tutorials/create_a_workspace&quot;&gt;catkin&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在终端输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;source /opt/ros/indigo/setup.bash
mkdir -p ~/catkin_ws/src
cd ~/catkin_ws/src
catkin_init_workspace
cd ~/catkin_ws/
catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python2 -DPYTHON_INCLUDE_DIR=/usr/include/python2.7 -DPYTHON_LIBRARY=/usr/lib/libpython2.7.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bashrc中加入&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;# ROS
indigo() {
  source /opt/ros/indigo/setup.bash
  export PYTHONPATH=/opt/ros/indigo/lib/python2.7/site-packages:$PYTHONPATH
  export PKG_CONFIG_PATH=&quot;/opt/ros/indigo/lib/pkgconfig:$PKG_CONFIG_PATH&quot;
  # Optionally, you can set:
  #export ROS_PACKAGE_PATH=/path/to/your/package/path:$ROS_PACKAGE_PATH

  # Useful aliases
  alias catkin_make=&quot;catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python2 -DPYTHON_INCLUDE_DIR=/usr/include/python2.7 -DPYTHON_LIBRARY=/usr/lib/libpython2.7.so&quot;

  # If you use Gazebo:
  #source /usr/share/gazebo/setup.sh
} 
source ~/catkin_ws/devel/setup.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终端输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;sudo rosdep init
rosdep update
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;三使用hector-slam&quot;&gt;三．使用hector-slam&lt;/h3&gt;

&lt;p&gt;1.终端输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;yaourt --noconfirm ros-indigo-hector-slam
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bashrc&lt;/code&gt;末尾加入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;export ROS_PACKAGE_PATH=/opt/ros/indigo/share/hector_slam_launch:$ROS_PACKAGE_PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.下载&lt;a href=&quot;https://code.google.com/p/tu-darmstadt-ros-pkg/downloads/list&quot;&gt;bag&lt;/a&gt;文件&lt;/p&gt;

&lt;p&gt;4.终端输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;roscore
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.新终端输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;roslaunch hector_slam_launch tutorial.launch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6.新终端输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;rosbag play Team_Hector_MappingBox_RoboCup_2011_Rescue_Arena.bag  --clock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/heavyhuang/docs/blob/master/pic/ros-slam.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;四安装ethzasl_icp_mapping&quot;&gt;四．安装&lt;a href=&quot;http://wiki.ros.org/ethzasl_icp_configuration&quot;&gt;ethzasl_icp_mapping&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;终端输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;git clone --recursive git://github.com/ethz-asl/ethzasl_icp_mapping.git
export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:`pwd`/ethzasl_icp_mapping
rosdep update
rosmaster ethzasl_icp_mapping
rosdep install ethzasl_icp_mapping
rosmake ethzasl_icp_mapping
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bashrc&lt;/code&gt;末尾加入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;export ROS_PACKAGE_PATH=/work/ros/ethzasl_icp_mapping:$ROS_PACKAGE_PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;五其它常用插件&quot;&gt;五．其它常用插件&lt;/h3&gt;

&lt;p&gt;状态图&lt;a href=&quot;http://wiki.ros.org/rqt_graph#Example&quot;&gt;rqt_graph&lt;/a&gt;（indigo中没有搜到rxgraph）:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;yaourt --noconfirm ros-indigo-rqt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相关书籍源码&lt;a href=&quot;https://www.packtpub.com/hardware-and-creative/learning-ros-robotics-programming&quot;&gt;链接1&lt;/a&gt; &lt;a href=&quot;https://www.packtpub.com/hardware-and-creative/learning-ros-robotics-programming-second-edition&quot;&gt;链接2&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;六入门范例&quot;&gt;六．入门范例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;roscore$
rosrun turtlesim turtlesim_node$
rosrun turtlesim turtle_teleop_key
&lt;/code&gt;&lt;/pre&gt;</content><summary type="html">一．arch上安装ROS</summary></entry><entry><title type="html">MySQL学习笔记</title><link href="http://localhost:4000/code/2016/12/14/mysql.html" rel="alternate" type="text/html" title="MySQL学习笔记" /><published>2016-12-14T22:32:38+08:00</published><updated>2016-12-14T22:32:38+08:00</updated><id>http://localhost:4000/code/2016/12/14/mysql</id><content type="html" xml:base="http://localhost:4000/code/2016/12/14/mysql.html">&lt;h3 id=&quot;行级锁定&quot;&gt;行级锁定&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;共享锁：&lt;/strong&gt;允许一个事物读一行数据时，阻止其他的事物读取相同数据的排他锁。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;排他锁：&lt;/strong&gt;允许获得排他锁的事物更新数据，阻止其他事物取得相同数据的共享锁和排他锁。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;意向共享锁：&lt;/strong&gt;事物打算给数据行加行共享锁。事务在给一个数据行加共享锁前必须先取得该表的意向共享锁。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;意向排他锁：&lt;/strong&gt;事物打算给数据行加行排他锁。事物在给一个数据行加排他锁前必须先取得该表的意向排他锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;表级锁定&quot;&gt;表级锁定&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;读锁定&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;写锁定&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;innodb行级锁&quot;&gt;InnoDB行级锁&lt;/h2&gt;
&lt;h3 id=&quot;acid特性&quot;&gt;ACID特性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;原子性：&lt;/strong&gt;一个原子事务要么完整执行，要么干脆不执行。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;一致性：&lt;/strong&gt;一致性代表了底层数据存储的完整性。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;隔离性：&lt;/strong&gt;意味着事务必须在不干扰其他进程或事务的前提下独立执行。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;持久性：&lt;/strong&gt;事务成功后，数据将会被持久化到数据库中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;并发时存在的问题&quot;&gt;并发时存在的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;更新丢失（应完全避免）：&lt;/strong&gt;两个事务同时更新一行数据，但事务2却中途失败退出了，导致两个修改都失效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;脏读：&lt;/strong&gt;事务1更新了记录但没有提交，事务2读取了更新后的行，导致事务1回滚，现在2读取无效。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不可重复读：&lt;/strong&gt;事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;幻读：&lt;/strong&gt;事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数据库隔离级别&quot;&gt;数据库隔离级别&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;READ UNCOMMITTED（未提交读）&lt;/strong&gt;：幻读，不可重复读和脏读均允许；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;READ COMMITTED（已提交读）&lt;/strong&gt;：允许幻读和不可重复读，但不允许脏读；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;REPEATABLE READ（可重复读）&lt;/strong&gt;：允许幻读，但不允许不可重复读和脏读；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SERIALIZABLE（可序列化）&lt;/strong&gt;:幻读，不可重复读和脏读都不允许；&lt;/li&gt;
  &lt;li&gt;ORACLE默认的是 READ COMMITTED&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;raid技术&quot;&gt;RAID技术&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;在实际的应用中，RAID2~4并不存在,因为RAID5已经涵盖了所需的功能。因此RAID2~4目前只有在研究领域有实作,而在实际应用上则以RAID 0、1、0+1、5或RAID6为主。但是对于我们普通用户来说，用的最多的也就是RAID 0、1、0+1和RAID 5。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;raid-0无差错控制的带区组&quot;&gt;RAID 0：无差错控制的带区组&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;要实现RAID0必须要有两个以上硬盘驱动器，RAID0实现了带区组，数据并不是保存在一个硬盘上，而是&lt;strong&gt;分成数据块保存在不同驱动器&lt;/strong&gt;上。因为将数据分布在不同驱动器上，所以数据&lt;strong&gt;吞吐率大大提高&lt;/strong&gt;，驱动器的&lt;strong&gt;负载也比较平衡&lt;/strong&gt;。如果刚好所需要的数据在不同的驱动器上效率最好。它不需要计算校验码，实现容易。它的缺点是它&lt;strong&gt;没有数据差错控制&lt;/strong&gt;，如果一个驱动器中的数据发生错误，即使其它盘上的数据正确也无济于事了。不应该将它用于对数据稳定性要求高的场合。&lt;strong&gt;如果用户进行图象（包括动画）编辑和其它要求传输比较大的场合使用RAID0比较合适。&lt;/strong&gt;同时，RAID可以提高数据传输速率，比如所需读取的文件分布在两个硬盘上，这两个硬盘可以同时读取。那么原来读取同样文件的时间被缩短为1/2。在所有的级别中，RAID 0的&lt;strong&gt;速度是最快&lt;/strong&gt;的。但是RAID 0没有冗余功能的，&lt;strong&gt;如果一个磁盘（物理）损坏，则所有的数据都无法使用。&lt;/strong&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;如果两块硬盘：160G+120G=240G&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;raid-1镜象结构&quot;&gt;RAID 1：镜象结构&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;对于使用这种RAID1结构的设备来说，RAID控制器必须能够&lt;strong&gt;同时对两个盘进行读操作和对两个镜象盘进行写操作&lt;/strong&gt;，&lt;strong&gt;必须有两个驱动器&lt;/strong&gt;。因为是镜象结构在一组盘出现问题时，可以使用镜象，提高系统的容错能力。它比较容易设计和实现。每读一次盘只能读出一块数据，也就是说数据块传送速率与单独的盘的读取速率相同。因为RAID1的&lt;strong&gt;校验十分完备&lt;/strong&gt;，因此对系统的处理能力有很大的影响，通常的RAID功能&lt;strong&gt;由软件实现&lt;/strong&gt;，而这样的实现方法在服务器负载比较重的时候会大大影响服务器效率。当您的系统&lt;strong&gt;需要极高的可靠性&lt;/strong&gt;时，如进行数据统计，那么使用RAID1比较合适。而且RAID1技术&lt;strong&gt;支持“热替换”&lt;/strong&gt;，即不断电的情况下对故障磁盘进行更换，更换完毕只要从镜像盘上恢复数据即可。当主硬盘损坏时，镜像硬盘就可以代替主硬盘工作。&lt;strong&gt;镜像硬盘相当于一个备份盘&lt;/strong&gt;，可想而知，这种硬盘模式的安全性是非常高的，RAID 1的数据&lt;strong&gt;安全性在所有的RAID级别上来说是最好&lt;/strong&gt;的。但是其磁盘的&lt;strong&gt;利用率却只有50%&lt;/strong&gt;，是所有RAID级别中最低的。&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;如果两块硬盘：160G+120G=120G&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;raid-10-与-01&quot;&gt;RAID 10 与 01&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;RAID10又称为RAID1+0，先进行镜像（RAID1），再进行条带存放（RAID0）&lt;/strong&gt;。Raid10方案造成了50%的磁盘浪费，但是它提供了200%的速度和单磁盘损坏的数据安全性，并且当同时损坏的磁盘不在同一Raid1中，就能保证数据安全性。假如磁盘中的某一块盘坏了，整个逻辑磁盘仍能正常工作的。
&lt;strong&gt;RAID01又称为RAID0+1，先进行条带存放（RAID0），再进行镜像（RAID1）。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;raid-2带海明码校验&quot;&gt;RAID 2：带海明码校验&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;从概念上讲，RAID 2 同RAID 3类似，两者都是将数据条块化分布于不同的硬盘上，条块单位为位或字节。然而RAID 2&lt;strong&gt;使用一定的编码技术来提供错误检查及恢复&lt;/strong&gt;。这种编码技术需要多个磁盘存放检查及恢复信息，使得RAID 2技术实施更复杂。因此，在&lt;strong&gt;商业环境中很少使用&lt;/strong&gt;。各个磁盘上是数据的各个位，由一个数据不同的位运算得到的&lt;strong&gt;海明校验码&lt;/strong&gt;可以保存另一组磁盘上。由于海明码的特点，它可以在数据发生错误的情况下将错误校正，以保证输出的正确。它的数据传送速率相当高，如果希望达到比较理想的速度，那最好提高保存校验码ECC码的硬盘，对于控制器的设计来说，它又比RAID3，4或5要简单。没有免费的午餐，这里也一样，要利用海明码，必须要付出数据冗余的代价。&lt;strong&gt;输出数据的速率与驱动器组中速度最慢的相等&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;raid-3带奇偶校验码的并行传送&quot;&gt;RAID 3：带奇偶校验码的并行传送&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;RAID3这种校验码与RAID2不同，&lt;strong&gt;只能查错不能纠错&lt;/strong&gt;。它访问数据时&lt;strong&gt;一次处理一个带区&lt;/strong&gt;，这样可以提高读取和写入速度,它像RAID 0一样以&lt;strong&gt;并行&lt;/strong&gt;的方式来存放数据，但速度没有RAID 0快。校验码在写入数据时产生并保存在另一个磁盘上。需要实现时用户&lt;strong&gt;必须要有三个以上的驱动器&lt;/strong&gt;，写入速率与读出速率都很高，因为校验位比较少，因此计算时间相对而言比较少。用软件实现RAID控制将是十分困难的，控制器的实现也不是很容易。它主要用于图形（包括动画）等要求吞吐率比较高的场合。不同于RAID 2，RAID 3&lt;strong&gt;使用单块磁盘存放奇偶校验信息&lt;/strong&gt;。&lt;strong&gt;如果一块磁盘失效，奇偶盘及其他数据盘可以重新产生数据。如果奇偶盘失效，则不影响数据使用。&lt;/strong&gt;RAID 3对于大量的连续数据可提供很好的传输率，但对于随机数据，奇偶盘会成为写操作的瓶颈。利用单独的校验盘来保护数据虽然没有镜像的安全性高，但是硬盘利用率得到了很大的提高，为（n-1）/n。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;raid-4带奇偶校验码的独立磁盘结构&quot;&gt;RAID 4：带奇偶校验码的独立磁盘结构&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;RAID4和RAID3很像，不同的是，它对数据的访问是按数据块进行的，也就是按磁盘进行的，每次是一个盘。它的特点和RAID3也挺像，不过在失败恢复时，它的难度可要比RAID3大得多了，控制器的设计难度也要大许多，而且访问数据的效率不怎么好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;raid-5分布式奇偶校验的独立磁盘结构&quot;&gt;RAID 5：分布式奇偶校验的独立磁盘结构&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;RAID 5 是一种存储性能、数据安全和存储成本兼顾的存储解决方案。 RAID 5可以理解为是RAID 0和RAID 1的折中方案。RAID 5可以为系统提供数据安全保障，但保障程度要比Mirror低而磁盘空间利用率要比Mirror高。RAID 5具有和RAID 0相近似的数据读取速度，只是多了一个奇偶校验信息，写入数据的速度比对单个磁盘进行写入操作稍慢。同时由于多个数据对应一个奇偶校验信息，RAID 5的磁盘空间利用率要比RAID 1高，存储成本相对较低，是目前&lt;strong&gt;运用较多的一种解决方案&lt;/strong&gt;。&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;RAID5校验位算法原理:P=D1 xor D2 xor D3 … xor Dn （D1,D2,D3 … Dn为数据块，P为校验，xor为异或运算）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;raid-50被称为分布奇偶位阵列条带&quot;&gt;RAID 50：被称为分布奇偶位阵列条带&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;同RAID 10相仿的，它具有RAID 5和RAID 0的共同特性。它由两组RAID 5磁盘组成（每组最少3个），每一组都使用了分布式奇偶位，而两组硬盘再组建成RAID 0，实验跨磁盘抽取数据。RAID 50提供可靠的数据存储和优秀的整体性能，并支持更大的卷尺寸。即使两个物理磁盘发生故障（每个阵列中一个），数据也可以顺利恢复过来。
RAID 50&lt;strong&gt;最少需要6个驱动器&lt;/strong&gt;，它最适合需要高可靠性存储、高读取速度、高数据传输性能的应用。这些应用包括事务处理和有许多用户存取小文件的办公应用程序。&lt;/p&gt;
&lt;/blockquote&gt;</content><summary type="html">行级锁定

  共享锁：允许一个事物读一行数据时，阻止其他的事物读取相同数据的排他锁。
  排他锁：允许获得排他锁的事物更新数据，阻止其他事物取得相同数据的共享锁和排他锁。
  意向共享锁：事物打算给数据行加行共享锁。事务在给一个数据行加共享锁前必须先取得该表的意向共享锁。
  意向排他锁：事物打算给数据行加行排他锁。事物在给一个数据行加排他锁前必须先取得该表的意向排他锁。</summary></entry><entry><title type="html">Archlinux</title><link href="http://localhost:4000/2016/12/14/archlinux.html" rel="alternate" type="text/html" title="Archlinux" /><published>2016-12-14T00:00:00+08:00</published><updated>2016-12-14T00:00:00+08:00</updated><id>http://localhost:4000/2016/12/14/archlinux</id><content type="html" xml:base="http://localhost:4000/2016/12/14/archlinux.html">&lt;hr /&gt;
&lt;p&gt;layout: post
title:  “Arch Linux随记”
date:   2016-12-14 22:32:38 +0800
categories: code
—————–&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;pacman -Sc #清除现有安装包外pacman缓存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;yaourt –noconfirm packge-name #自动编译安装，有时需输入密码&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若更新后界面出现显示问题，可在优化工具里更换主题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;使用Shell找寻文本中出现频率最高10个字符串
&lt;code class=&quot;highlighter-rouge&quot;&gt;方法一：&lt;/code&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;#!/bin/sh
cat file.txt |awk '{
a[$1++]
}
END{
  for(i in a){
  print i,a[i]
  }
}|sort -nr |head -n 10
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;方法二：&lt;/code&gt;&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;sort file.txt |uniq -c |sort -nr|head -n 10
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;mutt自动收发邮件脚本
    &lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;#!/bin/bash
cd /path
echo begin getmail
getmail -v -n 
cd ./temp
if test 0 -ne `ls ./ |wc -l`
then
rm ./*
fi
if test 0 -ne `ls ../homework/ |wc -l`
then
rm ../homework/*
fi
touch test.log
ls ~/Mail/inbox/new/ |awk '{
  temp_cat=&quot;cat ~/Mail/inbox/new/&quot;$NF&quot;|grep -e ^From:  &amp;gt;&amp;gt; test.log&quot;
  temp_munpack=&quot;munpack ~/Mail/inbox/new/&quot;$NF&quot; &amp;gt;&amp;gt;test.log&quot;
  system(temp_cat) 
  system(temp_munpack)
}'
sed  '/@/{N;s/\n/ /};s/.*&amp;lt;//g;s/&amp;gt;//g;s/(.*)//g' test.log &amp;gt;test2.log 
cat ./test2.log |awk '{
  print $2
  #temp_cp=&quot;cp &quot;$2&quot; ../homework/ans_&quot;$2
  temp_pyrun=&quot;python3 ../barcodes_evaluation.py &quot;$2&quot;  ../barcodes_gt_test.txt &amp;gt; ../homework/ans_&quot;$2
  system(temp_pyrun)
}'
cat ./test2.log |awk '{
temp1=&quot;echo homework results |mutt -s homework &quot;$1&quot; -a ../homework/ans_&quot;$2 
system(temp1)
}'
if test 0 -ne `ls ~/Mail/inbox/new/ |wc -l`
then
mv ~/Mail/inbox/new/* ~/Mail/inbox/cur/
fi
echo end send mail
cd ..
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;启动定时脚本&lt;code class=&quot;highlighter-rouge&quot;&gt;$systemctl start cronie.service&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;设置每小时自动运行&lt;code class=&quot;highlighter-rouge&quot;&gt;$crontab -e&lt;/code&gt;&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Bash&quot;&gt;`0 * * * * /path/reply_homework.sh`
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;查找含有某字符串的所有文件&lt;code class=&quot;highlighter-rouge&quot;&gt;grep -rni LogisticRegressionOutput*&lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`*`: 表示当前目录所有文件，也可以是某个文件名
`-r` 是递归查找
`-n` 是显示行号
`-R` 查找所有文件包含子目录
`-i` 忽略大小写
`grep -i pattern files`：不区分大小写地搜索。默认情况区分大小写。 
`grep -l pattern files`：只列出匹配的文件名。
`grep -L pattern files`：列出不匹配的文件名。 
`grep -w pattern files`：只匹配整个单词，而不是字符串的一部分（如匹配`magic`，而不是`magical`）。 
`grep -C number pattern files`：匹配的上下文分别显示`[number]`行。 
`grep pattern1 | pattern2 files`：显示匹配`pattern1`或`pattern2`的行。 
`grep pattern1 files | grep pattern2`：显示匹配`pattern1`又匹配`pattern2`的行。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lsof&lt;/code&gt;列出系统打开的文件&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`lsof -i` 用以显示符合条件的进程情况
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;netstat -nap | grep 10022&lt;/code&gt;列出端口10022的使用情况。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;查看线程占用
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`top -H`:一行显示一个线程。
`ps xH`:查看所有存在的线程。
`ps -mp &amp;lt;PID&amp;gt;`:查看一个进程起的线程数。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装过程如果遇到permission denied的提示，就找到相应的文件，用chmod +x赋予其可执行权限&lt;/p&gt;

&lt;p&gt;The directory /tmp/mathworks_30038/sys/java/jre/glnxa64/jre/bin/java does not exist.
/tmp/mathworks_30038/sys/java/jre/glnxa64/jre/bin/java does not appear to be a JRE directory.&lt;/p&gt;

&lt;p&gt;./install -javadir /NSFCGZ/app/java/jdk1.8.0_11/jre -inputFile installer_input.txt&lt;/p&gt;</content><summary type="html">layout: post
title:  “Arch Linux随记”
date:   2016-12-14 22:32:38 +0800
categories: code
—————–

  pacman -Sc #清除现有安装包外pacman缓存</summary></entry></feed>
