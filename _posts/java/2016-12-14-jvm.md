---
layout: post
title:  "深入了解Java虚拟机学习笔记"
date:   2016-12-14 22:32:38 +0800
categories: jekyll update
---

## 一.内存区域
### 1.程序计数器
线程私有，字节码的行号指示器，为了每个线程在CPU处理完后能恢复到正确位置。
### 2.Java虚拟机栈
线程私有，执行Java字节码，存有**局部变量表**（编译器可知基本数据类型，对象引用）、操作数栈、动态链接、方法出口等信息。
### 3.本地方法栈
执行Native方法。
### 4.Java堆
线程共享，存放对象实例和数组（不绝对），GC中新生代老年代，处于物理上不连续但逻辑连续的内存空间中。
### 5.方法区
线程共享，存放常量、静态变量、虚拟机加载的类信息，GC中永久代。
### 6.常量池
方法区一部分，存放编译期生成的各种字面量和符号引用，具备动态加载性。
### 7.直接内存
NIO中buffer分配内存，避免Java堆和Native堆中来回复制数据。

## 二.内存布局
### 1.对象头
- 第一部分储存对象运行时数据，包括哈希码、GC分代年龄、线程持有锁、偏向锁ID、偏向时间戳等，又称为“Mark Word”。
- 第二部分是类型指针，Jvm通过该指针确定这个对象是那个类的实例。若指向数组，则对象头还有一块用于记录数组长度。

### 2.实例数据
对象真正储存的有效信息，父类定义的变量会出现在子类之前。
### 3.对齐填充
Jvm要求对象起始地址必须是8字节的整数倍。当对象实例数据没有对齐时，通过对齐填充补全。

### 4.对象访问定位
使用句柄：
- Java堆划分出一块内存作为句柄池，reference(指向对象的引用)中储存对象句柄地址，句柄包含对象实例数据和类型数据各自具体地址信息。
- 对象被移动（垃圾回收时会移动对象）时只需改变句柄中实例指针。

直接指针：
- reference中直接储存对象地址。
- 速度快，节省一次指针定位开销。

## 三.垃圾收集算法

### 引用计数法
- 给对象添加一个引用计数器，被引用时加一；引用失效时减一。
- 很难解决循环引用的问题。

### 可达分析法
- GC Roots：虚拟机栈中引用的对象，静态引用的对象，常量引用的对象，JNI引用的对象。
- 强引用：Object obj = new Object();只要强引用在，垃圾收集器永远不会回收被引用的对象。
- 软引用：有用但非必需的对象。在内存溢出之前才会回收。SoftReference类实现软引用。
- 弱引用：强度低于软引用。被引用对象只能生存到下次垃圾收集前。
- 虚引用：最弱的引用。唯一作用对象被回收前收到一个系统通知。PhantonReference类。
- 若对象被判定执行finalize()方法，则会放到F-Queue队列中，并在稍后由一个虚拟机自动建立、低优先级的Finalizer线程去执行。
- F-Queue中对象可在GC对F-Queue进行二次标记前拯救自己。 

### 标记-清除法
- 用于回收老年代。
- 缺点：标记和清除两个效率低。会产生大量不连续空间碎片，可能导致分配较大对象时触发另一次垃圾回收。

### 复制算法
- 用于回收新生代。
- 将内存划分为较大的Eden代和两块较小的Survivor空间。
- 回收时将Eden和Survivor中还存活的对象一次性复制到另一块Survivor中，然后清理Eden和刚才的Suivivor空间。
- 若Survivor空间不够，则放入老年代。


### 标记-整理法
- 用于回收老年代。
- 类似标记-清除法，清除完后将存活对象在内存中向一端移动，然后直接清理边界以外的内存。

### 安全点（Safepoint）
- 程序到安全点时才停顿下来开始GC。
- 安全点选定不能太少让GC等待太长，也不能过于频繁增大运行时的负荷，以“是否让程序长时间执行的特征”来选定。
- 方法调用、循环跳转、异常跳转等功能指令会产生安全点。
- 抢先式中断（不推荐）
- 主动式中断：GC简单的设置一个标志，各线程轮询该标志，若发现标志为真则挂起。轮询标志和安全点位置重合。

## 四.垃圾收集器

### Serial收集器
- 新生代复制算法（暂停所有用户线程）
- 老年代标记-整理法（暂停所有用户线程）
- 单线程，简单而高效
- 能与CMS配合工作
- 指针碰撞，内存规整

### ParNew收集器
- Serial多线程版本
- 新生代复制算法（暂停所有线程，多线程）
- 老年代标记-整理法（暂停所有用户线程）
- 能与CMS配合工作 
- 指针碰撞，内存规整

### Parallel Scavenge收集器
- 新生代收集器，使用复制算法
- 吞吐量优先
- 打开-XX:+UseAdaptiveSizePolicy后不需手动指定新生代参数

### Serial Old收集器
- 新生代复制算法（暂停所有用户线程）
- 老年代标记-整理法（暂停所有用户线程）
- Serial老年代版本
- 可与Parallel Scavenge搭配使用。

### Parallel Old收集器
- Parallel Scavenge老年代版本
- 使用标记-整理法（多线程）
- 吞吐量优先（Parallel Scavenge + Parallel Old）

### CMS收集器
- 初始标记（Stop The World）：仅标记GC Roots直接关联对象。
- 并发标记：GC Roots Tracing
- 重新标记（Stop The World）
- 并发清除
- 低停顿，对CPU资源敏感
- 默认回收线程数(CPU数量+3)/4
- 无法处理标记过程后新出现的浮动垃圾，只能留到下一次CMS。
- 会产生大量空间碎片。
- -XX:+UseCMSCompactAtFullCollection参数用于Full GC时整理内存碎片。
- 空闲列表，内存相互交错

### G1收集器
- 并行与并发：使用多个CPU和CPU核缩短Stop The World时间。
- 将Java堆划分为多个大小相等的独立区域（Region），分代概念得以保留。
- 基于标记-整理法。
- 低停顿，可建立停顿时间模型，指定M毫秒停顿时间内垃圾回收不超过N毫秒。
- 建立每个区域内垃圾回收优先列表，在允许GC时间内，回收价值最大的。
- 使用Remembered Set避免全堆扫描。
- 每个区域有对应Remembered Set，JVM若发现对Reference类型数据操作时，产生Write Barrier中断写操作，检查Reference是否存在某些区域中。若存在，则通过CardTable记录到对应Remembered Set中。
- 初始标记（Stop The World）：GC Roots直接关联的对象。
- 并发标记：耗时较长，标记时产生的变化放入线程Remembered Set Logs中。
- 最终标记（Stop The World，可并行）：Remembered Set Logs合并到Remembered Set中。
- 筛选回收：区域价值成本排序，根据排序回收。

## 五.回收策略
### 对象优先在Eden分配
- Mirror GC：发生在新生代，非常频繁，回收速度快。
- Major GC / Full GC：发生在老年代，一般比Minor GC慢十倍以上。

### 大对象直接进入老年代
- 大对象指需要连续内存空间的对象，如长字符串、大数组。
- -XX：PretenureSizeThreshold参数：设置大于该参数的直接分配在老年代。

### 长期存活的对象将进入老年代
- -XX:MaxTenuringThreshold参数：晋升老年代阈值

### 动态对象年龄判定
- 相同年龄所有对象大小总和大于Survivor一半，大于等于该年龄的直接进入老年代。

### 空间分配担保
- Minor GC前，JVM会检查老年代最大可用连续空间是否大于新生代对象总空间，若大于，则说明Minor GC安全。
- HandlePromotionFailure参数:允许冒险
- 若小于，且设置不允许冒险，则进行Full GC.

## 六.JVM常用工具

### JDK命令行工具
- `jps`:虚拟机进程状况
- `jstat`:统计虚拟机信息
- `jinfo`: Java配置信息
- `jmap`: Java内存映像，获取dump文件（堆转储快照）
- `jhat`: dump分析工具
- `jstack`: Java堆栈跟踪工具
- `HSDIS`： JIT生成代码反汇编

### JDK可视化工具
- `JConsole`： Java监视与管理控制台
- `VisualVM`: 多合一故障处理工具
