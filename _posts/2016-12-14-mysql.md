---
layout: post
title:  "MySQL学习笔记"
date:   2016-12-14 22:32:38 +0800
categories: code
---

### 行级锁定
- **共享锁：**允许一个事物读一行数据时，阻止其他的事物读取相同数据的排他锁。
- **排他锁：**允许获得排他锁的事物更新数据，阻止其他事物取得相同数据的共享锁和排他锁。
- **意向共享锁：**事物打算给数据行加行共享锁。事务在给一个数据行加共享锁前必须先取得该表的意向共享锁。
- **意向排他锁：**事物打算给数据行加行排他锁。事物在给一个数据行加排他锁前必须先取得该表的意向排他锁。

### 表级锁定
- **读锁定**
- **写锁定**

## InnoDB行级锁
### ACID特性
- **原子性：**一个原子事务要么完整执行，要么干脆不执行。
- **一致性：**一致性代表了底层数据存储的完整性。
- **隔离性：**意味着事务必须在不干扰其他进程或事务的前提下独立执行。
- **持久性：**事务成功后，数据将会被持久化到数据库中。

### 并发时存在的问题
- **更新丢失（应完全避免）：**两个事务同时更新一行数据，但事务2却中途失败退出了，导致两个修改都失效。
- **脏读：**事务1更新了记录但没有提交，事务2读取了更新后的行，导致事务1回滚，现在2读取无效。
- **不可重复读：**事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录。
- **幻读：**事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录。

### 数据库隔离级别
- **READ UNCOMMITTED（未提交读）**：幻读，不可重复读和脏读均允许；
- **READ COMMITTED（已提交读）**：允许幻读和不可重复读，但不允许脏读；
- **REPEATABLE READ（可重复读）**：允许幻读，但不允许不可重复读和脏读；
- **SERIALIZABLE（可序列化）**:幻读，不可重复读和脏读都不允许； 
- ORACLE默认的是 READ COMMITTED

## RAID技术
> **在实际的应用中，RAID2~4并不存在,因为RAID5已经涵盖了所需的功能。因此RAID2~4目前只有在研究领域有实作,而在实际应用上则以RAID 0、1、0+1、5或RAID6为主。但是对于我们普通用户来说，用的最多的也就是RAID 0、1、0+1和RAID 5。**


### RAID 0：无差错控制的带区组
> 要实现RAID0必须要有两个以上硬盘驱动器，RAID0实现了带区组，数据并不是保存在一个硬盘上，而是**分成数据块保存在不同驱动器**上。因为将数据分布在不同驱动器上，所以数据**吞吐率大大提高**，驱动器的**负载也比较平衡**。如果刚好所需要的数据在不同的驱动器上效率最好。它不需要计算校验码，实现容易。它的缺点是它**没有数据差错控制**，如果一个驱动器中的数据发生错误，即使其它盘上的数据正确也无济于事了。不应该将它用于对数据稳定性要求高的场合。**如果用户进行图象（包括动画）编辑和其它要求传输比较大的场合使用RAID0比较合适。**同时，RAID可以提高数据传输速率，比如所需读取的文件分布在两个硬盘上，这两个硬盘可以同时读取。那么原来读取同样文件的时间被缩短为1/2。在所有的级别中，RAID 0的**速度是最快**的。但是RAID 0没有冗余功能的，**如果一个磁盘（物理）损坏，则所有的数据都无法使用。**
- 如果两块硬盘：160G+120G=240G

### RAID 1：镜象结构
> 对于使用这种RAID1结构的设备来说，RAID控制器必须能够**同时对两个盘进行读操作和对两个镜象盘进行写操作**，**必须有两个驱动器**。因为是镜象结构在一组盘出现问题时，可以使用镜象，提高系统的容错能力。它比较容易设计和实现。每读一次盘只能读出一块数据，也就是说数据块传送速率与单独的盘的读取速率相同。因为RAID1的**校验十分完备**，因此对系统的处理能力有很大的影响，通常的RAID功能**由软件实现**，而这样的实现方法在服务器负载比较重的时候会大大影响服务器效率。当您的系统**需要极高的可靠性**时，如进行数据统计，那么使用RAID1比较合适。而且RAID1技术**支持“热替换”**，即不断电的情况下对故障磁盘进行更换，更换完毕只要从镜像盘上恢复数据即可。当主硬盘损坏时，镜像硬盘就可以代替主硬盘工作。**镜像硬盘相当于一个备份盘**，可想而知，这种硬盘模式的安全性是非常高的，RAID 1的数据**安全性在所有的RAID级别上来说是最好**的。但是其磁盘的**利用率却只有50%**，是所有RAID级别中最低的。
> 
> - 如果两块硬盘：160G+120G=120G

### RAID 10 与 01
> **RAID10又称为RAID1+0，先进行镜像（RAID1），再进行条带存放（RAID0）**。Raid10方案造成了50%的磁盘浪费，但是它提供了200%的速度和单磁盘损坏的数据安全性，并且当同时损坏的磁盘不在同一Raid1中，就能保证数据安全性。假如磁盘中的某一块盘坏了，整个逻辑磁盘仍能正常工作的。
> **RAID01又称为RAID0+1，先进行条带存放（RAID0），再进行镜像（RAID1）。**

### RAID 2：带海明码校验
> 从概念上讲，RAID 2 同RAID 3类似，两者都是将数据条块化分布于不同的硬盘上，条块单位为位或字节。然而RAID 2**使用一定的编码技术来提供错误检查及恢复**。这种编码技术需要多个磁盘存放检查及恢复信息，使得RAID 2技术实施更复杂。因此，在**商业环境中很少使用**。各个磁盘上是数据的各个位，由一个数据不同的位运算得到的**海明校验码**可以保存另一组磁盘上。由于海明码的特点，它可以在数据发生错误的情况下将错误校正，以保证输出的正确。它的数据传送速率相当高，如果希望达到比较理想的速度，那最好提高保存校验码ECC码的硬盘，对于控制器的设计来说，它又比RAID3，4或5要简单。没有免费的午餐，这里也一样，要利用海明码，必须要付出数据冗余的代价。**输出数据的速率与驱动器组中速度最慢的相等**。

### RAID 3：带奇偶校验码的并行传送
> RAID3这种校验码与RAID2不同，**只能查错不能纠错**。它访问数据时**一次处理一个带区**，这样可以提高读取和写入速度,它像RAID 0一样以**并行**的方式来存放数据，但速度没有RAID 0快。校验码在写入数据时产生并保存在另一个磁盘上。需要实现时用户**必须要有三个以上的驱动器**，写入速率与读出速率都很高，因为校验位比较少，因此计算时间相对而言比较少。用软件实现RAID控制将是十分困难的，控制器的实现也不是很容易。它主要用于图形（包括动画）等要求吞吐率比较高的场合。不同于RAID 2，RAID 3**使用单块磁盘存放奇偶校验信息**。**如果一块磁盘失效，奇偶盘及其他数据盘可以重新产生数据。如果奇偶盘失效，则不影响数据使用。**RAID 3对于大量的连续数据可提供很好的传输率，但对于随机数据，奇偶盘会成为写操作的瓶颈。利用单独的校验盘来保护数据虽然没有镜像的安全性高，但是硬盘利用率得到了很大的提高，为（n-1）/n。

### RAID 4：带奇偶校验码的独立磁盘结构
> RAID4和RAID3很像，不同的是，它对数据的访问是按数据块进行的，也就是按磁盘进行的，每次是一个盘。它的特点和RAID3也挺像，不过在失败恢复时，它的难度可要比RAID3大得多了，控制器的设计难度也要大许多，而且访问数据的效率不怎么好。

### RAID 5：分布式奇偶校验的独立磁盘结构
> RAID 5 是一种存储性能、数据安全和存储成本兼顾的存储解决方案。 RAID 5可以理解为是RAID 0和RAID 1的折中方案。RAID 5可以为系统提供数据安全保障，但保障程度要比Mirror低而磁盘空间利用率要比Mirror高。RAID 5具有和RAID 0相近似的数据读取速度，只是多了一个奇偶校验信息，写入数据的速度比对单个磁盘进行写入操作稍慢。同时由于多个数据对应一个奇偶校验信息，RAID 5的磁盘空间利用率要比RAID 1高，存储成本相对较低，是目前**运用较多的一种解决方案**。
> - RAID5校验位算法原理:P=D1 xor D2 xor D3 … xor Dn （D1,D2,D3 … Dn为数据块，P为校验，xor为异或运算）

### RAID 50：被称为分布奇偶位阵列条带
> 同RAID 10相仿的，它具有RAID 5和RAID 0的共同特性。它由两组RAID 5磁盘组成（每组最少3个），每一组都使用了分布式奇偶位，而两组硬盘再组建成RAID 0，实验跨磁盘抽取数据。RAID 50提供可靠的数据存储和优秀的整体性能，并支持更大的卷尺寸。即使两个物理磁盘发生故障（每个阵列中一个），数据也可以顺利恢复过来。
> RAID 50**最少需要6个驱动器**，它最适合需要高可靠性存储、高读取速度、高数据传输性能的应用。这些应用包括事务处理和有许多用户存取小文件的办公应用程序。
