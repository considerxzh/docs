# 深入了解Java虚拟机学习笔记 #
-----------------
## 一.内存区域
### 1.程序计数器
线程私有，字节码的行号指示器，为了每个线程在CPU处理完后能恢复到正确位置。
### 2.Java虚拟机栈
线程私有，执行Java字节码，存有局部变量表（编译器可知基本数据类型，对象引用）、操作数栈、动态链接、方法出口等信息。
### 3.本地方法栈
执行Native方法。
### 4.Java堆
线程共享，存放对象实例和数组（不绝对），GC中新生代老年代，处于物理上不连续但逻辑连续的内存空间中。
### 5.方法区
线程共享，存放常量、静态变量、虚拟机加载的类信息，GC中永久代。
### 6.常量池
方法区一部分，存放编译期生成的各种字面量和符号引用，具备动态加载性。
### 7.直接内存
NIO中buffer分配内存，避免Java堆和Native堆中来回复制数据。

## 二.内存布局
### 1.对象头
- 第一部分储存对象运行时数据，包括哈希码、GC分代年龄、线程持有锁、偏向锁ID、偏向时间戳等，又称为“Mark Word”。
- 第二部分是类型指针，Jvm通过该指针确定这个对象是那个类的实例。若指向数组，则对象头还有一块用于记录数组长度。

### 2.实例数据
对象真正储存的有效信息，父类定义的变量会出现在子类之前。
### 3.对齐填充
Jvm要求对象起始地址必须是8字节的整数倍。当对象实例数据没有对齐时，通过对齐填充补全。

### 4.对象访问定位
使用句柄：
- Java堆划分出一块内存作为句柄池，reference(指向对象的引用)中储存对象句柄地址，句柄包含对象实例数据和类型数据各自具体地址信息。
- 对象被移动（垃圾回收时会移动对象）时只需改变句柄中实例指针。

直接指针：
- reference中直接储存对象地址。
- 速度快，节省一次指针定位开销。

## 三.垃圾收集器与内存分配策略
### 引用计数法
### 可达分析法
### 标记-清除法
### 标记-整理法
### Serial收集器
### ParNew收集器
### Parallel Scavenge收集器
### Serial Old收集器
### Parallel Old收集器
### CMS收集器
### G1收集器



Serial、ParNew指针碰撞，内存规整
CMS空闲列表，内存相互交错